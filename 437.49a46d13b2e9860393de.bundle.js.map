{"version":3,"file":"437.49a46d13b2e9860393de.bundle.js","mappings":"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","sources":["webpack://tweb/./src/config/debug.ts","webpack://tweb/./src/config/modes.ts","webpack://tweb/./src/config/tabId.ts","webpack://tweb/./src/environment/ctx.ts","webpack://tweb/./src/helpers/array/findAndSplice.ts","webpack://tweb/./src/helpers/array/indexOfAndSplice.ts","webpack://tweb/./src/helpers/dT.ts","webpack://tweb/./src/helpers/eventListenerBase.ts","webpack://tweb/./src/helpers/makeError.ts","webpack://tweb/./src/lib/mtproto/superMessagePort.ts"],"sourcesContent":["/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport Modes from './modes';\r\n\r\nexport const DEBUG = (process.env.NODE_ENV !== 'production' || Modes.debug)/*  && false */;\r\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\r\nexport const MOUNT_CLASS_TO: any = DEBUG || true/*  && false */ ? ctx : {};\r\nexport default DEBUG;\r\n\r\n// let m = DEBUG;\r\n/* if(!DEBUG) {\r\n  ctx.sandpitTurtle = () => {\r\n    //if(!m) {\r\n      for(let i in MOUNT_CLASS_TO) {\r\n        ctx[i] = MOUNT_CLASS_TO[i];\r\n      }\r\n      //m = true;\r\n    //}\r\n\r\n    //DEBUG = !DEBUG;\r\n  };\r\n} */\r\n\r\n/* export const superDebug = (object: any, key: string) => {\r\n  var d = object[key];\r\n  var beforeStr = '', afterStr = '';\r\n  for(var r of d) {\r\n    beforeStr += r.before.hex + '\\n';\r\n    afterStr += r.after.hex + '\\n';\r\n  }\r\n\r\n  beforeStr = beforeStr.trim();\r\n  afterStr = afterStr.trim();\r\n  //var beforeStr = d.map((r) => r.before.hex).join('\\n');\r\n  //var afterStr = d.map((r) => r.after.hex).join('\\n');\r\n\r\n  var dada = (name: string, str: string) => {\r\n    var a = document.createElement('a');\r\n    a.target = '_blank';\r\n    a.download = name + '.txt';\r\n    a.href = URL.createObjectURL(new Blob([str], {\r\n      type: 'text/plain'\r\n    }));\r\n    document.body.append(a);\r\n    a.click();\r\n  };\r\n\r\n  dada(key + '_' + 'before', beforeStr);\r\n  dada(key + '_' + 'after', afterStr);\r\n}\r\n\r\nMOUNT_CLASS_TO.superDebug = superDebug; */\r\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n *\n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport type {TransportType} from '../lib/mtproto/dcConfigurator';\n\nconst Modes = {\n  test: location.search.indexOf('test=1') > 0/*  || true */,\n  debug: location.search.indexOf('debug=1') > 0,\n  http: false,\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\n  multipleConnections: true,\n  asServiceWorker: false,\n  transport: 'websocket' as TransportType\n};\n\n                       \nModes.http = location.search.indexOf('http=1') > 0;\n         \n\n                                      \n                  \n         \n\nif(Modes.http) {\n  Modes.transport = 'https';\n}\n\n                 \n                             \n         \n\nexport default Modes;\n","const tabId = Date.now() % Math.random() * 100000000 | 0;\r\nexport default tabId;\r\n","const ctx = typeof(window) !== 'undefined' ? window : self;\r\n\r\nexport default ctx;\r\n","export default function findAndSplice<T>(array: Array<T>, verify: (value: T, index?: number, array?: Array<T>) => boolean) {\r\n  const index = array.findIndex(verify);\r\n  return index !== -1 ? array.splice(index, 1)[0] : undefined;\r\n};\r\n","export default function indexOfAndSplice<T>(array: Array<T>, item: T) {\r\n  const idx = array.indexOf(item);\r\n  const spliced = idx === -1 ? undefined : array.splice(idx, 1);\r\n  return spliced?.[0];\r\n}\r\n","const _logTimer = Date.now();\r\nexport default function dT() {\r\n  return '[' + ((Date.now() - _logTimer) / 1000).toFixed(3) + ']';\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// import { MOUNT_CLASS_TO } from \"../config/debug\";\r\nimport type {ArgumentTypes, SuperReturnType} from '../types';\r\nimport findAndSplice from './array/findAndSplice';\r\n\r\n// class EventSystem {\r\n//   wm: WeakMap<any, Record<any, Set<any>>> = new WeakMap();\r\n\r\n//   add(target: any, event: any, listener: any) {\r\n//     let listeners = this.wm.get(target);\r\n//     if (listeners === undefined) {\r\n//         listeners = {};\r\n//     }\r\n//     let listenersForEvent = listeners[event];\r\n//     if (listenersForEvent === undefined) {\r\n//         listenersForEvent = new Set();\r\n//     }\r\n//     listenersForEvent.add(listener);\r\n//     listeners[event] = listenersForEvent;\r\n//     //target.addEventListener(event, listener);\r\n//     this.wm.set(target, listeners);\r\n//   };\r\n\r\n//   remove(target: any, event: any, listener: any) {\r\n//     let listeners = this.wm.get(target);\r\n//     if (!listeners) return;\r\n//     let listenersForEvent = listeners[event];\r\n//     if (!listenersForEvent) return;\r\n//     listenersForEvent.delete(listener);\r\n//   };\r\n\r\n//   /* fire(target, event) {\r\n//      let listeners = this.wm.get(target);\r\n//      if (!listeners) return;\r\n//      let listenersForEvent = listeners[event];\r\n//      if (!listenersForEvent) return;\r\n//      for (let handler of handlers) {\r\n//          setTimeout(handler, 0, event, target); // we use a setTimeout here because we want event triggering to be asynchronous.\r\n//      }\r\n//   }; */\r\n// }\r\n\r\n// console.log = () => {};\r\n\r\n// const e = new EventSystem();\r\n// MOUNT_CLASS_TO.e = e;\r\n\r\nexport type EventListenerListeners = Record<string, Function>;\r\n// export type EventListenerListeners = Record<string, (...args: any[]) => any>;\r\n// export type EventListenerListeners = {[name in string]: Function};\r\n\r\n/**\r\n * Better not to remove listeners during setting\r\n * Should add listener callback only once\r\n */\r\n\r\ntype ListenerObject<T> = {callback: T, options: boolean | AddEventListenerOptions};\r\n\r\n// type EventLitenerCallback<T> = (data: T) =>\r\n// export default class EventListenerBase<Listeners extends {[name: string]: Function}> {\r\nexport default class EventListenerBase<Listeners extends EventListenerListeners> {\r\n  protected listeners: Partial<{\r\n    [k in keyof Listeners]: Array<ListenerObject<Listeners[k]>>\r\n  }>;\r\n  protected listenerResults: Partial<{\r\n    [k in keyof Listeners]: ArgumentTypes<Listeners[k]>\r\n  }>;\r\n\r\n  private reuseResults: boolean;\r\n\r\n  constructor(reuseResults?: boolean) {\r\n    this._constructor(reuseResults);\r\n  }\r\n\r\n  public _constructor(reuseResults?: boolean): any {\r\n    this.reuseResults = reuseResults;\r\n    this.listeners = {};\r\n    this.listenerResults = {};\r\n  }\r\n\r\n  public addEventListener<T extends keyof Listeners>(name: T, callback: Listeners[T], options?: boolean | AddEventListenerOptions) {\r\n    (this.listeners[name] ??= []).push({callback, options}); // ! add before because if you don't, you won't be able to delete it from callback\r\n\r\n    if(this.listenerResults.hasOwnProperty(name)) {\r\n      callback(...this.listenerResults[name]);\r\n\r\n      if((options as AddEventListenerOptions)?.once) {\r\n        this.listeners[name].pop();\r\n        return;\r\n      }\r\n    }\r\n\r\n    // e.add(this, name, {callback, once});\r\n  }\r\n\r\n  public addMultipleEventsListeners(obj: {\r\n    [name in keyof Listeners]?: Listeners[name]\r\n  }) {\r\n    for(const i in obj) {\r\n      this.addEventListener(i, obj[i]);\r\n    }\r\n  }\r\n\r\n  public removeEventListener<T extends keyof Listeners>(name: T, callback: Listeners[T], options?: boolean | AddEventListenerOptions) {\r\n    if(this.listeners[name]) {\r\n      findAndSplice(this.listeners[name], (l) => l.callback === callback);\r\n    }\r\n    // e.remove(this, name, callback);\r\n  }\r\n\r\n  protected invokeListenerCallback<T extends keyof Listeners, L extends ListenerObject<any>>(name: T, listener: L, ...args: ArgumentTypes<L['callback']>) {\r\n    let result: any;\r\n    try {\r\n      result = listener.callback(...args);\r\n    } catch(err) {\r\n      console.error(err);\r\n    }\r\n\r\n    if((listener.options as AddEventListenerOptions)?.once) {\r\n      this.removeEventListener(name, listener.callback);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private _dispatchEvent<T extends keyof Listeners>(name: T, collectResults: boolean, ...args: ArgumentTypes<Listeners[T]>) {\r\n    if(this.reuseResults) {\r\n      this.listenerResults[name] = args;\r\n    }\r\n\r\n    const arr: Array<SuperReturnType<Listeners[typeof name]>> = collectResults && [];\r\n\r\n    const listeners = this.listeners[name];\r\n    if(listeners) {\r\n      // ! this one will guarantee execution even if delete another listener during setting\r\n      const left = listeners.slice();\r\n      left.forEach((listener) => {\r\n        const index = listeners.findIndex((l) => l.callback === listener.callback);\r\n        if(index === -1) {\r\n          return;\r\n        }\r\n\r\n        const result = this.invokeListenerCallback(name, listener, ...args);\r\n        if(arr) {\r\n          arr.push(result);\r\n        }\r\n      });\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  public dispatchResultableEvent<T extends keyof Listeners>(name: T, ...args: ArgumentTypes<Listeners[T]>) {\r\n    return this._dispatchEvent(name, true, ...args);\r\n  }\r\n\r\n  // * must be protected, but who cares\r\n  public dispatchEvent<L extends EventListenerListeners = Listeners, T extends keyof L = keyof L>(name: T, ...args: ArgumentTypes<L[T]>) {\r\n    // @ts-ignore\r\n    this._dispatchEvent(name, false, ...args);\r\n  }\r\n\r\n  public cleanup() {\r\n    this.listeners = {};\r\n    this.listenerResults = {};\r\n  }\r\n}\r\n","export default function makeError(type: Error['type']) {\r\n  const error: ApiError = {\r\n    type\r\n  };\r\n\r\n  return error;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport DEBUG from '../../config/debug';\r\nimport tabId from '../../config/tabId';\r\nimport ctx from '../../environment/ctx';\r\nimport indexOfAndSplice from '../../helpers/array/indexOfAndSplice';\r\nimport {IS_WORKER} from '../../helpers/context';\r\nimport EventListenerBase from '../../helpers/eventListenerBase';\r\nimport makeError from '../../helpers/makeError';\r\nimport {Awaited, WorkerTaskTemplate, WorkerTaskVoidTemplate} from '../../types';\r\nimport {logger} from '../logger';\r\n\r\ntype SuperMessagePortTask = WorkerTaskTemplate & {\r\n  transfer?: Transferable[]\r\n};\r\n\r\ninterface InvokeTask extends SuperMessagePortTask {\r\n  type: 'invoke',\r\n  payload: WorkerTaskVoidTemplate & {withAck?: boolean, void?: boolean}\r\n}\r\n\r\ninterface ResultTask extends SuperMessagePortTask {\r\n  type: 'result',\r\n  payload: {\r\n    taskId: number,\r\n    result?: any,\r\n    error?: any\r\n  }\r\n}\r\n\r\ninterface AckTask extends SuperMessagePortTask {\r\n  type: 'ack',\r\n  payload: {\r\n    cached: boolean,\r\n    taskId: number\r\n    result?: any,\r\n    error?: any,\r\n  }\r\n}\r\n\r\ninterface PingTask extends SuperMessagePortTask {\r\n  type: 'ping'\r\n}\r\n\r\ninterface PongTask extends SuperMessagePortTask {\r\n  type: 'pong'\r\n}\r\n\r\ninterface BatchTask extends SuperMessagePortTask {\r\n  type: 'batch',\r\n  payload: Task[]\r\n}\r\n\r\ninterface CloseTask extends SuperMessagePortTask {\r\n  type: 'close'\r\n}\r\n\r\n// interface OpenTask extends SuperMessagePortTask {\r\n//   type: 'open'\r\n// }\r\n\r\ninterface LockTask extends SuperMessagePortTask {\r\n  type: 'lock',\r\n  payload: string\r\n}\r\n\r\ntype Task = InvokeTask | ResultTask | AckTask | PingTask | PongTask | BatchTask | CloseTask/*  | OpenTask */ | LockTask;\r\ntype TaskMap = {\r\n  [type in Task as type['type']]?: (task: Extract<Task, type>, source: MessageEventSource, event: MessageEvent<any>) => void | Promise<any>\r\n};\r\n\r\nexport type AckedResult<T> = {\r\n  cached: boolean,\r\n  result: Promise<T>\r\n};\r\n// export type AckedResult<T> = {\r\n//   cached: true,\r\n//   result: T\r\n// } | {\r\n//   cached: false,\r\n//   result: Promise<T>\r\n// };\r\n\r\ntype ListenPort = WindowProxy | MessagePort | ServiceWorker | Worker | ServiceWorkerContainer;\r\ntype SendPort = Pick<MessageEventSource, 'postMessage'>/* WindowProxy | MessagePort | ServiceWorker | Worker */;\r\n\r\nexport type MessageListenPort = ListenPort;\r\nexport type MessageSendPort = SendPort;\r\n\r\ntype ListenerCallback = (payload: any, source: MessageEventSource, event: MessageEvent<any>) => any;\r\ntype Listeners = Record<string, ListenerCallback>;\r\n\r\n// const PING_INTERVAL = DEBUG && false ? 0x7FFFFFFF : 5000;\r\n// const PING_TIMEOUT = DEBUG && false ? 0x7FFFFFFF : 10000;\r\n\r\nexport default class SuperMessagePort<\r\n  Workers extends Listeners,\r\n  Masters extends Listeners,\r\n  IsMaster extends boolean,\r\n  Receive extends Listeners = IsMaster extends true ? Masters : Workers,\r\n  Send extends Listeners = IsMaster extends true ? Workers : Masters\r\n> extends EventListenerBase<Receive> {\r\n  protected listenPorts: Array<ListenPort>;\r\n  protected sendPorts: Array<SendPort>;\r\n  protected pingResolves: Map<SendPort, () => void>;\r\n\r\n  protected taskId: number;\r\n  protected awaiting: {\r\n    [id: number]: {\r\n      resolve: any,\r\n      reject: any,\r\n      taskType: string,\r\n      port?: SendPort\r\n    }\r\n  };\r\n  protected pending: Map<SendPort, Task[]>;\r\n\r\n  protected log: ReturnType<typeof logger>;\r\n  protected debug: boolean;\r\n  protected releasingPending: boolean;\r\n\r\n  protected processTaskMap: TaskMap;\r\n\r\n  protected onPortDisconnect: (source: MessageEventSource) => void;\r\n  // protected onPortConnect: (source: MessageEventSource) => void;\r\n\r\n  protected heldLocks: Map<SendPort, {resolve: () => void, id: string}>;\r\n  protected requestedLocks: Map<string, SendPort>;\r\n\r\n  constructor(protected logSuffix?: string) {\r\n    super(false);\r\n\r\n    this.listenPorts = [];\r\n    this.sendPorts = [];\r\n    this.pingResolves = new Map();\r\n    this.taskId = 0;\r\n    this.awaiting = {};\r\n    this.pending = new Map();\r\n    this.log = logger('MP' + (logSuffix ? '-' + logSuffix : ''));\r\n    this.debug = DEBUG;\r\n    this.heldLocks = new Map();\r\n    this.requestedLocks = new Map();\r\n\r\n    this.processTaskMap = {\r\n      result: this.processResultTask,\r\n      ack: this.processAckTask,\r\n      invoke: this.processInvokeTask,\r\n      ping: this.processPingTask,\r\n      pong: this.processPongTask,\r\n      close: this.processCloseTask,\r\n      // open: this.processOpenTask,\r\n      lock: this.processLockTask\r\n    };\r\n  }\r\n\r\n  public setOnPortDisconnect(callback: (source: MessageEventSource) => void) {\r\n    this.onPortDisconnect = callback;\r\n  }\r\n\r\n  // public setOnPortConnect(callback: (source: MessageEventSource) => void) {\r\n  //   this.onPortConnect = callback;\r\n  // }\r\n\r\n  public attachPort(port: MessageEventSource) {\r\n    this.attachListenPort(port);\r\n    this.attachSendPort(port);\r\n  }\r\n\r\n  public attachListenPort(port: ListenPort) {\r\n    this.listenPorts.push(port);\r\n    port.addEventListener('message', this.onMessage as any);\r\n  }\r\n\r\n  public attachSendPort(port: SendPort) {\r\n    this.log.warn('attaching send port');\r\n\r\n    (port as MessagePort).start?.();\r\n\r\n    this.sendPorts.push(port);\r\n    // this.sendPing(port);\r\n\r\n    // const task = this.createTask('open', undefined);\r\n    // this.postMessage(port, task);\r\n\r\n    if(typeof(window) !== 'undefined') {\r\n      if('locks' in navigator) {\r\n        const id = ['lock', tabId, this.logSuffix || '', Math.random() * 0x7FFFFFFF | 0].join('-');\r\n        this.log.warn('created lock', id);\r\n        const promise = new Promise<void>((resolve) => this.heldLocks.set(port, {resolve, id}))\r\n        .then(() => this.heldLocks.delete(port));\r\n        navigator.locks.request(id, () => {\r\n          this.resendLockTask(port);\r\n          return promise;\r\n        });\r\n      } else {\r\n        window.addEventListener('beforeunload', () => {\r\n          const task = this.createTask('close', undefined);\r\n          this.postMessage(undefined, task);\r\n        });\r\n      }\r\n    }\r\n\r\n    this.releasePending();\r\n  }\r\n\r\n  public resendLockTask(port: SendPort) {\r\n    const lock = this.heldLocks.get(port);\r\n    if(!lock) {\r\n      return;\r\n    }\r\n\r\n    this.pushTask(this.createTask('lock', lock.id), port);\r\n  }\r\n\r\n  // ! Can't rely on ping because timers can be suspended\r\n  // protected sendPing(port: SendPort, loop = IS_WORKER) {\r\n  //   let timeout: number;\r\n  //   const promise = new Promise<void>((resolve, reject) => {\r\n  //     this.pingResolves.set(port, resolve);\r\n  //     this.pushTask(this.createTask('ping', undefined), port);\r\n\r\n  //     timeout = ctx.setTimeout(() => {\r\n  //       reject();\r\n  //     }, PING_TIMEOUT);\r\n  //   });\r\n\r\n  //   promise.then(() => {\r\n  //     // this.log('got pong');\r\n\r\n  //     clearTimeout(timeout);\r\n  //     this.pingResolves.delete(port);\r\n\r\n  //     if(loop) {\r\n  //       this.sendPingWithTimeout(port);\r\n  //     }\r\n  //   }, () => {\r\n  //     this.pingResolves.delete(port);\r\n  //     this.detachPort(port);\r\n  //   });\r\n  // }\r\n\r\n  // protected sendPingWithTimeout(port: SendPort, timeout = PING_INTERVAL) {\r\n  //   ctx.setTimeout(() => {\r\n  //     if(!this.sendPorts.includes(port)) {\r\n  //       return;\r\n  //     }\r\n\r\n  //     this.sendPing(port);\r\n  //   }, timeout);\r\n  // }\r\n\r\n  public detachPort(port: ListenPort) {\r\n    this.log.warn('disconnecting port');\r\n\r\n    indexOfAndSplice(this.listenPorts, port);\r\n    indexOfAndSplice(this.sendPorts, port as any);\r\n\r\n    port.removeEventListener?.('message', this.onMessage as any);\r\n    (port as MessagePort).close?.();\r\n\r\n    this.onPortDisconnect?.(port as any);\r\n\r\n    const heldLock = this.heldLocks.get(port as SendPort);\r\n    heldLock?.resolve();\r\n\r\n    const error = makeError('PORT_DISCONNECTED');\r\n    for(const id in this.awaiting) {\r\n      const task = this.awaiting[id];\r\n      if(task.port === port) {\r\n        task.reject(error);\r\n        delete this.awaiting[id];\r\n      }\r\n    }\r\n  }\r\n\r\n  protected postMessage(port: SendPort | SendPort[], task: Task) {\r\n    const ports = Array.isArray(port) ? port : (port ? [port] : this.sendPorts);\r\n    ports.forEach((port) => {\r\n      port.postMessage(task, task.transfer as any);\r\n    });\r\n  }\r\n\r\n  protected onMessage = (event: MessageEvent) => {\r\n    const task: Task = event.data;\r\n    // this.log('got message', task);\r\n\r\n    const source: MessageEventSource = event.source || event.currentTarget as any; // can have no source\r\n    /* if(task.type === 'batch') {\r\n      const newEvent: MessageEvent = {data: event.data, source: event.source, currentTarget: event.currentTarget} as any;\r\n      task.payload.forEach((task) => {\r\n        // @ts-ignore\r\n        newEvent.data = task;\r\n        this.onMessage(newEvent);\r\n      });\r\n    } */\r\n\r\n    // @ts-ignore\r\n    this.processTaskMap[task.type](task, source, event);\r\n  };\r\n\r\n  protected /* async */ releasePending() {\r\n    // return;\r\n\r\n    if(/* !this.listenPorts.length || !this.sendPorts.length ||  */this.releasingPending) {\r\n      return;\r\n    }\r\n\r\n    this.releasingPending = true;\r\n    // const perf = performance.now();\r\n    // await pause(0);\r\n\r\n    this.debug && this.log.debug('releasing tasks, length:', this.pending.size/* , performance.now() - perf */);\r\n\r\n    this.pending.forEach((portTasks, port) => {\r\n      // let batchTask: BatchTask;\r\n      // const tasks: Task[] = [];\r\n      // portTasks.forEach((task) => {\r\n      //   if(task.transfer) {\r\n      //     batchTask = undefined;\r\n      //     tasks.push(task);\r\n      //   } else {\r\n      //     if(!batchTask) {\r\n      //       batchTask = this.createTask('batch', []);\r\n      //       tasks.push(batchTask);\r\n      //     }\r\n\r\n      //     batchTask.payload.push(task);\r\n      //   }\r\n      // });\r\n\r\n      const tasks = portTasks;\r\n      const ports = port ? [port] : this.sendPorts;\r\n      if(!ports.length) {\r\n        return;\r\n      }\r\n\r\n      tasks.forEach((task) => {\r\n        // if(task.type === 'batch') {\r\n        //   this.log(`batching ${task.payload.length} tasks`);\r\n        // }\r\n\r\n        try {\r\n          // if(IS_SERVICE_WORKER && !port) {\r\n          //   notifyAll(task);\r\n          // } else {\r\n          this.postMessage(ports, task);\r\n          // }\r\n        } catch(err) {\r\n          this.log.error('postMessage error:', err, task, ports);\r\n        }\r\n      });\r\n\r\n      this.pending.delete(port);\r\n    });\r\n\r\n    this.debug && this.log.debug('released tasks');\r\n\r\n    this.releasingPending = false;\r\n  }\r\n\r\n  protected processResultTask = (task: ResultTask) => {\r\n    const {taskId, result, error} = task.payload;\r\n    const deferred = this.awaiting[taskId];\r\n    if(!deferred) {\r\n      return;\r\n    }\r\n\r\n    this.debug && this.log.debug('done', deferred.taskType, result, error);\r\n    'error' in task.payload ? deferred.reject(error) : deferred.resolve(result);\r\n    delete this.awaiting[taskId];\r\n  };\r\n\r\n  protected processAckTask = (task: AckTask) => {\r\n    const payload = task.payload;\r\n    const deferred = this.awaiting[payload.taskId];\r\n    if(!deferred) {\r\n      return;\r\n    }\r\n\r\n    // * will finish the init promise with incoming result\r\n    const previousResolve: (acked: AckedResult<any>) => void = deferred.resolve;\r\n    // const previousReject = deferred.reject;\r\n\r\n    // if(payload.cached) {\r\n    //   if('result' in payload) {\r\n    //     previousResolve({\r\n    //       cached: true,\r\n    //       result: payload.result\r\n    //     });\r\n    //   } else {\r\n    //     previousReject(payload.error);\r\n    //   }\r\n    // } else {\r\n    //   const ret: AckedResult<any> = {\r\n    //     cached: false,\r\n    //     result: new Promise((resolve, reject) => {\r\n    //       deferred.resolve = resolve;\r\n    //       deferred.reject = reject;\r\n    //     })\r\n    //   };\r\n\r\n    //   previousResolve(ret);\r\n    // }\r\n\r\n    const ret: AckedResult<any> = {\r\n      cached: payload.cached,\r\n      result: payload.cached ? ('result' in payload ? Promise.resolve(payload.result) : Promise.reject(payload.error)) : new Promise((resolve, reject) => {\r\n        deferred.resolve = resolve;\r\n        deferred.reject = reject;\r\n      })\r\n    };\r\n\r\n    previousResolve(ret);\r\n\r\n    if(payload.cached) {\r\n      delete this.awaiting[payload.taskId];\r\n    }\r\n  };\r\n\r\n  protected processPingTask = (task: PingTask, source: MessageEventSource, event: MessageEvent) => {\r\n    this.pushTask(this.createTask('pong', undefined), event.source);\r\n  };\r\n\r\n  protected processPongTask = (task: PongTask, source: MessageEventSource, event: MessageEvent) => {\r\n    const pingResolve = this.pingResolves.get(source);\r\n    if(pingResolve) {\r\n      this.pingResolves.delete(source);\r\n      pingResolve();\r\n    }\r\n  };\r\n\r\n  protected processCloseTask = (task: CloseTask, source: MessageEventSource, event: MessageEvent) => {\r\n    this.detachPort(source);\r\n  };\r\n\r\n  // * it's just an 'open' callback, DO NOT attach port from here\r\n  // protected processOpenTask = (task: OpenTask, source: MessageEventSource, event: MessageEvent) => {\r\n  //   this.onPortConnect?.(source);\r\n  // };\r\n\r\n  protected processLockTask = (task: LockTask, source: MessageEventSource, event: MessageEvent) => {\r\n    const id = task.payload;\r\n    if(this.requestedLocks.has(id)) {\r\n      return;\r\n    }\r\n\r\n    this.requestedLocks.set(id, source);\r\n    navigator.locks.request(id, () => {\r\n      this.processCloseTask(undefined, source, undefined);\r\n      this.requestedLocks.delete(id);\r\n    });\r\n  };\r\n\r\n  protected processInvokeTask = async(task: InvokeTask, source: MessageEventSource, event: MessageEvent) => {\r\n    const id = task.id;\r\n    const innerTask = task.payload;\r\n\r\n    let resultTaskPayload: ResultTask['payload'];\r\n    let resultTask: ResultTask, ackTask: AckTask;\r\n    if(!innerTask.void) {\r\n      resultTaskPayload = {taskId: id};\r\n      resultTask = this.createTask('result', resultTaskPayload);\r\n    }\r\n\r\n    if(innerTask.withAck) {\r\n      ackTask = this.createTask('ack', {\r\n        taskId: id,\r\n        cached: true\r\n      });\r\n    }\r\n\r\n    let isPromise: boolean;\r\n    try {\r\n      const listeners = this.listeners[innerTask.type];\r\n      if(!listeners?.length) {\r\n        throw new Error('no listener');\r\n      }\r\n\r\n      const listener = listeners[0];\r\n\r\n      // @ts-ignore\r\n      let result = this.invokeListenerCallback(innerTask.type, listener, innerTask.payload, source, event);\r\n      if(innerTask.void) {\r\n        return;\r\n      }\r\n\r\n      isPromise = result instanceof Promise;\r\n\r\n      if(ackTask) {\r\n        const cached = !isPromise;\r\n        ackTask.payload.cached = cached;\r\n        if(cached) ackTask.payload.result = result;\r\n        this.pushTask(ackTask, source);\r\n\r\n        if(cached) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      if(isPromise) {\r\n        result = await result;\r\n      }\r\n\r\n      resultTaskPayload.result = result;\r\n    } catch(error) {\r\n      this.log.error('worker task error:', error, task);\r\n      if(innerTask.void) {\r\n        return;\r\n      }\r\n\r\n      if(ackTask && ackTask.payload.cached) {\r\n        ackTask.payload.error = error;\r\n        this.pushTask(ackTask, source);\r\n        return;\r\n      }\r\n\r\n      resultTaskPayload.error = error;\r\n    }\r\n\r\n    this.pushTask(resultTask, source);\r\n  };\r\n\r\n  protected createTask<T extends Task['type'], K extends Task = Parameters<TaskMap[T]>[0]>(type: T, payload: K['payload'], transfer?: Transferable[]): K {\r\n    return {\r\n      type,\r\n      payload,\r\n      id: this.taskId++,\r\n      transfer\r\n    } as K;\r\n  }\r\n\r\n  protected createInvokeTask(type: string, payload: any, withAck?: boolean, _void?: boolean, transfer?: Transferable[]): InvokeTask {\r\n    return this.createTask('invoke', {\r\n      type,\r\n      payload,\r\n      withAck,\r\n      void: _void\r\n    }, transfer);\r\n  }\r\n\r\n  protected pushTask(task: Task, port?: SendPort) {\r\n    let tasks = this.pending.get(port);\r\n    if(!tasks) {\r\n      this.pending.set(port, tasks = []);\r\n    }\r\n\r\n    tasks.push(task);\r\n    this.releasePending();\r\n  }\r\n\r\n  public invokeVoid<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], port?: SendPort, transfer?: Transferable[]) {\r\n    const task = this.createInvokeTask(type as string, payload, undefined, true, transfer);\r\n    this.pushTask(task, port);\r\n  }\r\n\r\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: false, port?: SendPort, transfer?: Transferable[]): Promise<Awaited<ReturnType<Send[T]>>>;\r\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: true, port?: SendPort, transfer?: Transferable[]): Promise<AckedResult<Awaited<ReturnType<Send[T]>>>>;\r\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: boolean, port?: SendPort, transfer?: Transferable[]) {\r\n    this.debug && this.log.debug('start', type, payload);\r\n\r\n    let task: InvokeTask;\r\n    const promise = new Promise<Awaited<ReturnType<Send[T]>>>((resolve, reject) => {\r\n      task = this.createInvokeTask(type as string, payload, withAck, undefined, transfer);\r\n      this.awaiting[task.id] = {resolve, reject, taskType: type as string, port};\r\n      this.pushTask(task, port);\r\n    });\r\n\r\n    if(IS_WORKER) {\r\n      promise.finally(() => {\r\n        clearInterval(interval);\r\n      });\r\n\r\n      const interval = ctx.setInterval(() => {\r\n        this.log.error('task still has no result', task, port);\r\n      }, 60e3);\r\n    } else if(false) {\r\n      // let timedOut = false;\r\n      const startTime = Date.now();\r\n      promise.finally(() => {\r\n        const elapsedTime = Date.now() - startTime;\r\n        if(elapsedTime >= TIMEOUT) {\r\n          this.log.error(`task was processing ${Date.now() - startTime}ms`, task.payload.payload, port);\r\n        }/*  else {\r\n          clearTimeout(timeout);\r\n        } */\r\n      });\r\n\r\n      const TIMEOUT = 10;\r\n      // const timeout = ctx.setTimeout(() => {\r\n      //   timedOut = true;\r\n      //   // this.log.error(`task is processing more than ${TIMEOUT} milliseconds`, task, port);\r\n      // }, TIMEOUT);\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  public invokeExceptSource<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], source?: SendPort) {\r\n    const ports = this.sendPorts.slice();\r\n    indexOfAndSplice(ports, source);\r\n\r\n    ports.forEach((target) => {\r\n      this.invokeVoid(type, payload, target);\r\n    });\r\n  }\r\n}\r\n"],"names":["DEBUG","MOUNT_CLASS_TO","window","self","Modes","test","location","search","indexOf","debug","http","ssl","multipleConnections","asServiceWorker","transport","Date","now","Math","random","findAndSplice","array","verify","index","findIndex","splice","undefined","indexOfAndSplice","item","idx","spliced","_logTimer","dT","toFixed","EventListenerBase","constructor","reuseResults","this","_constructor","listeners","listenerResults","addEventListener","name","callback","options","push","hasOwnProperty","once","pop","addMultipleEventsListeners","obj","i","removeEventListener","l","invokeListenerCallback","listener","args","result","err","console","error","_dispatchEvent","collectResults","arr","slice","forEach","dispatchResultableEvent","dispatchEvent","cleanup","makeError","type","SuperMessagePort","logSuffix","super","onMessage","event","task","data","source","currentTarget","processTaskMap","processResultTask","taskId","payload","deferred","awaiting","log","taskType","reject","resolve","processAckTask","previousResolve","cached","Promise","processPingTask","pushTask","createTask","processPongTask","pingResolve","pingResolves","get","delete","processCloseTask","detachPort","processLockTask","id","requestedLocks","has","set","navigator","locks","request","processInvokeTask","innerTask","resultTaskPayload","resultTask","ackTask","isPromise","void","withAck","length","Error","listenPorts","sendPorts","Map","pending","heldLocks","ack","invoke","ping","pong","close","lock","setOnPortDisconnect","onPortDisconnect","attachPort","port","attachListenPort","attachSendPort","warn","start","join","promise","then","resendLockTask","postMessage","releasePending","heldLock","Array","isArray","transfer","releasingPending","size","portTasks","tasks","ports","createInvokeTask","_void","invokeVoid","finally","clearInterval","interval","invokeExceptSource","target"],"sourceRoot":""}